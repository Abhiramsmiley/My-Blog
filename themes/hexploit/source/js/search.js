/**
 * Frontend-only search implementation for Hexo using search.json
 * Features: debouncing, fuzzy matching, efficient for 500+ posts
 */

(function() {
  'use strict';

  // Configuration
  const SEARCH_PATH = '/search.json';
  const DEBOUNCE_DELAY = 200; // ms
  const MAX_RESULTS = 10;
  const CONTEXT_LENGTH = 120;

  // Cache for search data
  let searchData = null;
  let searchIndex = null;
  let isLoading = false;

  /**
   * Debounce function to limit search frequency
   */
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  /**
   * Load search data from search.json
   */
  async function loadSearchData() {
    if (searchData) return searchData;
    if (isLoading) return null;

    isLoading = true;
    try {
      const response = await fetch(SEARCH_PATH);
      if (!response.ok) throw new Error('Failed to load search.json');
      searchData = await response.json();
      
      // Pre-process data for faster searching
      searchData = searchData.map(item => ({
        ...item,
        titleLower: (item.title || '').toLowerCase(),
        contentLower: (item.content || '').replace(/<[^>]+>/g, ' ').toLowerCase(),
        tagsLower: (item.tags || []).map(t => (typeof t === 'string' ? t : t.name || '')).join(' ').toLowerCase()
      }));
      
      console.log('[Search] Loaded', searchData.length, 'posts');
      return searchData;
    } catch (error) {
      console.error('[Search] Error loading data:', error);
      return null;
    } finally {
      isLoading = false;
    }
  }

  /**
   * Escape HTML to prevent XSS
   */
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Highlight matching keywords in text
   */
  function highlightText(text, keywords) {
    if (!text || !keywords.length) return text;
    
    let result = escapeHtml(text);
    keywords.forEach(keyword => {
      if (keyword.length > 0) {
        const regex = new RegExp(`(${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
        result = result.replace(regex, '<mark class="search-highlight">$1</mark>');
      }
    });
    return result;
  }

  /**
   * Extract relevant context around keyword match
   */
  function getMatchContext(content, keywords) {
    if (!content) return '';
    
    const lowerContent = content.toLowerCase();
    let firstMatch = -1;
    let matchedKeyword = '';

    // Find first keyword match
    for (const keyword of keywords) {
      const idx = lowerContent.indexOf(keyword);
      if (idx !== -1 && (firstMatch === -1 || idx < firstMatch)) {
        firstMatch = idx;
        matchedKeyword = keyword;
      }
    }

    if (firstMatch === -1) {
      // No match in content, return start
      return content.substring(0, CONTEXT_LENGTH) + (content.length > CONTEXT_LENGTH ? '...' : '');
    }

    // Get context around match
    const start = Math.max(0, firstMatch - 30);
    const end = Math.min(content.length, firstMatch + CONTEXT_LENGTH - 30);
    let context = content.substring(start, end);
    
    // Add ellipsis
    if (start > 0) context = '...' + context;
    if (end < content.length) context += '...';

    return context;
  }

  /**
   * Calculate relevance score for a result
   */
  function calculateScore(item, keywords) {
    let score = 0;
    
    keywords.forEach(keyword => {
      // Title match (highest priority)
      if (item.titleLower.includes(keyword)) {
        score += 10;
        // Exact title match
        if (item.titleLower === keyword) score += 5;
        // Title starts with keyword
        if (item.titleLower.startsWith(keyword)) score += 3;
      }
      
      // Tags match (medium priority)
      if (item.tagsLower.includes(keyword)) {
        score += 5;
      }
      
      // Content match (lower priority)
      if (item.contentLower.includes(keyword)) {
        score += 2;
        // Bonus for multiple occurrences (capped)
        const occurrences = (item.contentLower.match(new RegExp(keyword, 'g')) || []).length;
        score += Math.min(occurrences, 5);
      }
    });
    
    return score;
  }

  /**
   * Perform search with keywords
   */
  function performSearch(query, data) {
    if (!query || !data) return [];

    // Split query into keywords and filter empty
    const keywords = query.toLowerCase().trim().split(/[\s+]+/).filter(k => k.length > 0);
    if (!keywords.length) return [];

    // Search and score results
    const results = [];
    
    for (const item of data) {
      // Check if ALL keywords match (AND logic)
      const allMatch = keywords.every(keyword => 
        item.titleLower.includes(keyword) || 
        item.contentLower.includes(keyword) ||
        item.tagsLower.includes(keyword)
      );
      
      if (allMatch) {
        const score = calculateScore(item, keywords);
        results.push({ item, score, keywords });
      }
    }

    // Sort by score (descending) and limit results
    results.sort((a, b) => b.score - a.score);
    return results.slice(0, MAX_RESULTS);
  }

  /**
   * Render search results to DOM
   */
  function renderResults(results, container) {
    if (!container) return;

    if (!results || results.length === 0) {
      container.innerHTML = '<div class="search-no-results">No results found</div>';
      return;
    }

    const html = results.map(({ item, keywords }) => {
      const title = highlightText(item.title || 'Untitled', keywords);
      const plainContent = (item.content || '').replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
      const context = getMatchContext(plainContent, keywords);
      const highlightedContext = highlightText(context, keywords);
      const tags = item.tags || [];
      
      let tagsHtml = '';
      if (tags.length > 0) {
        const tagNames = tags.map(t => typeof t === 'string' ? t : t.name || '').filter(Boolean).slice(0, 3);
        tagsHtml = `<div class="search-result-tags">${tagNames.map(t => `<span class="search-tag">#${escapeHtml(t)}</span>`).join(' ')}</div>`;
      }

      return `
        <a href="${item.url}" class="search-result-item">
          <div class="search-result-title">${title}</div>
          <div class="search-result-excerpt">${highlightedContext}</div>
          ${tagsHtml}
        </a>
      `;
    }).join('');

    container.innerHTML = html;
  }

  /**
   * Initialize search functionality
   */
  function initSearch() {
    const searchInput = document.getElementById('search-input');
    const searchResults = document.getElementById('search-results');

    if (!searchInput || !searchResults) {
      console.warn('[Search] Search elements not found');
      return;
    }

    // Preload search data on first focus
    searchInput.addEventListener('focus', () => {
      loadSearchData();
    }, { once: true });

    // Handle search input with debouncing
    const debouncedSearch = debounce(async (query) => {
      if (!query.trim()) {
        searchResults.innerHTML = '';
        return;
      }

      // Show loading state
      searchResults.innerHTML = '<div class="search-loading"><i class="fas fa-spinner fa-spin"></i> Searching...</div>';

      const data = await loadSearchData();
      if (!data) {
        searchResults.innerHTML = '<div class="search-error">Failed to load search data</div>';
        return;
      }

      const results = performSearch(query, data);
      renderResults(results, searchResults);
    }, DEBOUNCE_DELAY);

    searchInput.addEventListener('input', (e) => {
      debouncedSearch(e.target.value);
    });

    // Clear results on close
    const searchOverlay = document.getElementById('search-overlay');
    if (searchOverlay) {
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
            if (searchOverlay.classList.contains('hidden')) {
              searchInput.value = '';
              searchResults.innerHTML = '';
            }
          }
        });
      });
      observer.observe(searchOverlay, { attributes: true });
    }

    console.log('[Search] Initialized');
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSearch);
  } else {
    initSearch();
  }
})();
